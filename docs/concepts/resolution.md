# 解決

解決は、要件のリストを取得し、それらの要件を満たすパッケージバージョンのリストに変換するプロセスです。解決には、要求された要件が満たされ、要求されたパッケージの要件が互換性があることを確認するために、互換性のあるパッケージバージョンを再帰的に検索する必要があります。

## 依存関係

ほとんどのプロジェクトやパッケージには依存関係があります。依存関係は、現在のパッケージが動作するために必要な他のパッケージです。パッケージは、パッケージ名と許容されるバージョンの組み合わせである_要件_として依存関係を定義します。現在のプロジェクトによって定義された依存関係は_直接依存関係_と呼ばれます。現在のプロジェクトの各依存関係によって追加された要件は_間接_または_推移的依存関係_と呼ばれます。

!!! note

    依存関係の詳細については、Python Packagingのドキュメントの[依存関係指定子ページ](https://packaging.python.org/en/latest/specifications/dependency-specifiers/)を参照してください。

## 基本的な例

解決プロセスを説明するために、次の依存関係を考えてみましょう：

<!-- prettier-ignore -->
- プロジェクトは`foo`と`bar`に依存しています。
- `foo`には1つのバージョン、1.0.0があります：
    - `foo 1.0.0`は`lib>=1.0.0`に依存しています。
- `bar`には1つのバージョン、1.0.0があります：
    - `bar 1.0.0`は`lib>=2.0.0`に依存しています。
- `lib`には2つのバージョン、1.0.0と2.0.0があります。どちらのバージョンにも依存関係はありません。

この例では、リゾルバはプロジェクトの要件を満たすパッケージバージョンのセットを見つける必要があります。`foo`と`bar`のバージョンは1つしかないため、それらが使用されます。解決には推移的依存関係も含まれる必要があるため、`lib`のバージョンを選択する必要があります。`foo 1.0.0`は利用可能なすべてのバージョンの`lib`を許可しますが、`bar 1.0.0`は`lib>=2.0.0`を必要とするため、`lib 2.0.0`を使用する必要があります。

一部の解決では、複数の解決策があります。次の依存関係を考えてみましょう：

<!-- prettier-ignore -->
- プロジェクトは`foo`と`bar`に依存しています。
- `foo`には2つのバージョン、1.0.0と2.0.0があります：
    - `foo 1.0.0`には依存関係はありません。
    - `foo 2.0.0`は`lib==2.0.0`に依存しています。
- `bar`には2つのバージョン、1.0.0と2.0.0があります：
    - `bar 1.0.0`には依存関係はありません。
    - `bar 2.0.0`は`lib==1.0.0`に依存しています。
- `lib`には2つのバージョン、1.0.0と2.0.0があります。どちらのバージョンにも依存関係はありません。

この例では、`foo`と`bar`のいずれかのバージョンを選択する必要がありますが、どのバージョンを選択するかは`foo`と`bar`の各バージョンの依存関係を考慮する必要があります。`foo 2.0.0`と`bar 2.0.0`は、`lib`の必要なバージョンが競合するため、一緒にインストールすることはできません。そのため、リゾルバは`foo 1.0.0`または`bar 1.0.0`のいずれかを選択する必要があります。どちらも有効な解決策であり、異なる解決アルゴリズムはどちらの結果を与えることもあります。

## プラットフォームマーカー

マーカーを使用すると、依存関係にいつ使用するかを示す式を添付できます。たとえば、`bar; python_version<"3.9"`を使用して、Python 3.8およびそれ以前のバージョンでのみ`bar`を必要とすることができます。

マーカーは、現在の環境やプラットフォームに応じてパッケージの依存関係を調整するために使用されます。たとえば、マーカーを使用して、オペレーティングシステム、CPUアーキテクチャ、Pythonバージョン、Python実装などに基づいて依存関係を変更できます。

!!! note

    マーカーの詳細については、Python Packagingのドキュメントの[環境マーカー](https://packaging.python.org/en/latest/specifications/dependency-specifiers/#environment-markers)セクションを参照してください。

マーカーは、依存関係の値を変更するため、解決にとって重要です。通常、Pythonパッケージリゾルバは、パッケージが現在のプラットフォームにインストールされているため、_現在の_プラットフォームのマーカーを使用してどの依存関係を使用するかを決定します。ただし、依存関係を_ロック_する場合、これは問題です。ロックファイルは、ロックファイルが作成されたプラットフォームと同じプラットフォームを使用する開発者にのみ機能します。この問題を解決するために、プラットフォームに依存しない、または「ユニバーサル」リゾルバが存在します。

uvは、[プラットフォーム固有](#platform-specific-resolution)および[ユニバーサル](#universal-resolution)の解決をサポートしています。

## ユニバーサル解決

uvのロックファイル（`uv.lock`）はユニバーサル解決で作成され、プラットフォーム間で移植可能です。これにより、オペレーティングシステム、アーキテクチャ、Pythonバージョンに関係なく、プロジェクトに取り組むすべての人の依存関係がロックされます。uvのロックファイルは、`uv lock`、`uv sync`、`uv add`などの[プロジェクト](../concepts/projects.md)コマンドによって作成および変更されます。

ユニバーサル解決は、`--universal`フラグを使用して、uvのpipインターフェース（つまり、[`uv pip compile`](../pip/compile.md)）でも利用できます。結果の要件ファイルには、各依存関係がどのプラットフォームに関連するかを示すマーカーが含まれます。

ユニバーサル解決中に、異なるプラットフォームに異なるバージョンが必要な場合、パッケージは異なるバージョンまたはURLで複数回リストされることがあります。マーカーはどのバージョンが使用されるかを決定します。ユニバーサル解決は、すべてのマーカーの要件を考慮する必要があるため、プラットフォーム固有の解決よりも制約が多いことがよくあります。

ユニバーサル解決中に、最小のPythonバージョンを指定する必要があります。プロジェクトコマンドは、`pyproject.toml`の`project.requires-python`から最小必要バージョンを読み取ります。pipインターフェースを使用する場合は、`--python-version`オプションで値を指定します。指定しない場合、現在のPythonバージョンが下限として扱われます。たとえば、`--universal --python-version 3.9`は、Python 3.9以降のユニバーサル解決を記述します。

最小のPythonバージョンを設定することは重要です。すべてのパッケージバージョンは、Pythonバージョン範囲と互換性がある必要があります。たとえば、`numpy<2`のユニバーサル解決で`--python-version 3.8`を指定すると、`numpy==1.24.4`に解決されますが、`--python-version 3.9`を指定すると、`numpy==1.26.4`に解決されます。`numpy`の1.26.4以降のリリースはPython 3.9+を必要とするためです。上限は常に無視されます。

## プラットフォーム固有の解決

デフォルトでは、uvのpipインターフェース（つまり、[`uv pip compile`](../pip/compile.md)）は、`pip-tools`のようにプラットフォーム固有の解決を生成します。uvのプロジェクトインターフェースでは、プラットフォーム固有の解決を使用する方法はありません。

uvは、`--python-platform`および`--python-version`オプションを使用して、特定の代替プラットフォームおよびPythonバージョンの解決もサポートしています。たとえば、macOSでPython 3.12を使用している場合、`uv pip compile --python-platform linux --python-version 3.10 requirements.in`を使用して、Linux上のPython 3.10の解決を生成できます。ユニバーサル解決とは異なり、プラットフォーム固有の解決中に提供された`--python-version`は、下限ではなく、使用する正確なPythonバージョンです。

!!! note

    Pythonの環境マーカーは、現在のマシンに関する情報を、単純な`--python-platform`引数で表現できる以上に公開します。たとえば、macOSの`platform_version`マーカーには、カーネルがビルドされた時刻が含まれており、理論的にはパッケージ要件にエンコードできます。uvのリゾルバは、ターゲット`--python-platform`で実行される任意のマシンと互換性のある解決を生成するために最善の努力を行いますが、複雑なパッケージとプラットフォームの組み合わせでは忠実度が低下する可能性があります。

## 依存関係の優先順位

解決出力ファイル（つまり、uvのロックファイル（`uv.lock`）または要件出力ファイル（`requirements.txt`））が存在する場合、uvはそこにリストされている依存関係のバージョンを_優先_します。同様に、仮想環境にパッケージをインストールする場合、uvはすでにインストールされているバージョンを優先します。これにより、互換性のないバージョンが要求されるか、`--upgrade`で明示的にアップグレードが要求されない限り、ロックされたバージョンやインストールされたバージョンは変更されません。

## 解決戦略

デフォルトでは、uvは各パッケージの最新バージョンを使用しようとします。たとえば、`uv pip install flask>=2.0.0`はFlaskの最新バージョン（例：3.0.0）をインストールします。`flask>=2.0.0`がプロジェクトの依存関係である場合、`flask` 3.0.0のみが使用されます。これは重要です。たとえば、テストを実行しても、プロジェクトが実際に`flask` 2.0.0の下限と互換性があるかどうかを確認しないためです。

`--resolution lowest`を使用すると、uvはすべての依存関係（直接および間接（推移的））の最も低いバージョンをインストールします。代わりに、`--resolution lowest-direct`を使用すると、すべての直接依存関係の最も低い互換バージョンを使用し、他のすべての依存関係の最新の互換バージョンを使用します。uvは常にビルド依存関係の最新バージョンを使用します。

たとえば、次の`requirements.in`ファイルがあるとします：

```python title="requirements.in"
flask>=2.0.0
```

`uv pip compile requirements.in`を実行すると、次の`requirements.txt`ファイルが生成されます：

```python title="requirements.txt"
# このファイルは、次のコマンドを介してuvによって自動生成されました：
#    uv pip compile requirements.in
blinker==1.7.0
    # flask経由
click==8.1.7
    # flask経由
flask==3.0.0
itsdangerous==2.1.2
    # flask経由
jinja2==3.1.2
    # flask経由
markupsafe==2.1.3
    # jinja2経由
    # werkzeug経由
werkzeug==3.0.1
    # flask経由
```

ただし、`uv pip compile --resolution lowest requirements.in`を実行すると、代わりに次のようになります：

```python title="requirements.in"
# このファイルは、次のコマンドを介してuvによって自動生成されました：
#    uv pip compile requirements.in --resolution lowest
click==7.1.2
    # flask経由
flask==2.0.0
itsdangerous==2.0.0
    # flask経由
jinja2==3.0.0
    # flask経由
markupsafe==2.0.0
    # jinja2経由
werkzeug==2.0.0
    # flask経由
```

ライブラリを公開する場合、宣言された下限との互換性を確認するために、継続的インテグレーションで`--resolution lowest`または`--resolution lowest-direct`を使用してテストを個別に実行することをお勧めします。

## プレリリースの取り扱い

デフォルトでは、uvは次の2つの場合に依存関係の解決中にプレリリースバージョンを受け入れます：

1. パッケージが直接依存関係であり、そのバージョン指定子にプレリリース指定子が含まれている場合（例：`flask>=2.0.0rc1`）。
1. パッケージのすべての公開バージョンがプレリリースである場合。

推移的プレリリースによる依存関係の解決が失敗した場合、uvはすべての依存関係に対してプレリリースを許可するために`--prerelease allow`の使用を促します。

または、推移的依存関係をプレリリースバージョン指定子（例：`flask>=2.0.0rc1`）で[制約](#dependency-constraints)または直接依存関係（つまり、`requirements.in`または`pyproject.toml`）として追加して、その特定の依存関係に対してプレリリースサポートをオプトインすることもできます。

プレリリースは[モデル化が非常に難しい](https://pubgrub-rs-guide.netlify.app/limitations/prerelease_versions)ものであり、他のパッケージングツールでのバグの頻繁な原因です。uvのプレリリースの取り扱いは意図的に制限されており、正確性を確保するためにプレリリースのオプトインが必要です。

詳細については、[プレリリースの互換性](../pip/compatibility.md#pre-release-compatibility)を参照してください。

## 依存関係の制約

pipと同様に、uvは指定されたパッケージの許容バージョンの範囲を狭める制約ファイル（`--constraint constraints.txt`）をサポートしています。制約ファイルは要件ファイルに似ていますが、制約としてリストされているだけでは解決にパッケージが含まれることはありません。代わりに、制約は要求されたパッケージがすでに直接または推移的依存関係として引き込まれている場合にのみ効果を発揮します。制約は、推移的依存関係の利用可能なバージョンの範囲を減らすのに役立ちます。また、解決を他の解決済みバージョンセットと同期させるためにも使用できます。

## 依存関係のオーバーライド

依存関係のオーバーライドを使用すると、パッケージの宣言された依存関係を上書きして、失敗または望ましくない解決を回避できます。オーバーライドは、メタデータが示すにもかかわらず、依存関係が特定のバージョンのパッケージと互換性があることを知っている場合に便利な最後の手段です。

たとえば、推移的依存関係が`pydantic>=1.0,<2.0`を要求しているが、実際には`pydantic>=2.0`と互換性がある場合、ユーザーはオーバーライドに`pydantic>=1.0,<3`を含めることで、リゾルバが新しいバージョンの`pydantic`を選択できるようにします。

具体的には、`pydantic>=1.0,<3`がオーバーライドに含まれている場合、uvは`pydantic`に対するすべての宣言された要件を無視し、それらをオーバーライドに置き換えます。上記の例では、`pydantic>=1.0,<2.0`の要件は完全に無視され、代わりに`pydantic>=1.0,<3`に置き換えられます。

制約はパッケージの許容バージョンのセットを減らすことしかできませんが、オーバーライドは許容バージョンのセットを拡大し、誤った上限バージョンの回避策を提供します。制約と同様に、オーバーライドはパッケージに依存関係を追加せず、パッケージが直接または推移的依存関係で要求された場合にのみ効果を発揮します。

`pyproject.toml`では、`tool.uv.override-dependencies`を使用してオーバーライドのリストを定義します。pip互換インターフェースでは、制約ファイルと同じ形式のファイルを渡すために`--override`オプションを使用できます。

同じパッケージに対して複数のオーバーライドが提供される場合、それらは[マーカー](#platform-markers)で区別する必要があります。パッケージにマーカー付きの依存関係がある場合、オーバーライドを使用する際には、マーカーが真か偽かに関係なく無条件に置き換えられます。

## 依存関係のメタデータ

解決中に、uvは各パッケージのメタデータを解決して、その依存関係を特定する必要があります。このメタデータは通常、パッケージインデックスに静的ファイルとして提供されますが、ソースディストリビューションのみを提供するパッケージの場合、メタデータは事前に利用できないことがあります。

そのような場合、uvはパッケージをビルドしてメタデータを特定する必要があります（例：`setup.py`を呼び出す）。これにより、解決中にパフォーマンスのペナルティが発生する可能性があります。さらに、パッケージがすべてのプラットフォームでビルド可能である必要があるという要件が課されますが、これは必ずしも真ではありません。

たとえば、Linuxでのみビルドおよびインストールされるべきパッケージがあり、macOSやWindowsではビルドに失敗する場合があります。このシナリオのために完全に有効なロックファイルを構築することはできますが、パッケージをビルドする必要があり、非Linuxプラットフォームでは失敗します。

`tool.uv.dependency-metadata`テーブルを使用して、そのような依存関係の静的メタデータを事前に提供し、uvがビルドステップをスキップして提供されたメタデータを使用できるようにします。

たとえば、`chumpy`のメタデータを事前に提供するには、`pyproject.toml`にその`dependency-metadata`を含めます：

```toml
[[tool.uv.dependency-metadata]]
name = "chumpy"
version = "0.70"
requires-dist = ["numpy>=1.8.1", "scipy>=0.13.0", "six>=1.11.0"]
```

これらの宣言は、パッケージが事前に静的メタデータを宣言しない場合を意図していますが、ビルド分離を無効にする必要があるパッケージにも役立ちます。そのような場合、パッケージのメタデータを事前に宣言する方が、パッケージを解決する前にカスタムビルド環境を作成するよりも簡単です。

たとえば、`flash-attn`のメタデータを宣言して、uvがソースからパッケージをビルドせずに解決できるようにします（これ自体が`torch`のインストールを必要とします）：

```toml
[[tool.uv.dependency-metadata]]
name = "flash-attn"
version = "2.6.3"
requires-dist = ["torch", "einops"]
```

依存関係のオーバーライドと同様に、`tool.uv.dependency-metadata`は、パッケージのメタデータが不正確または不完全である場合や、パッケージがパッケージインデックスに存在しない場合にも使用できます。依存関係のオーバーライドは、パッケージの許容バージョンをグローバルに上書きすることができますが、メタデータのオーバーライドは特定のパッケージの宣言されたメタデータを上書きすることができます。

`tool.uv.dependency-metadata`テーブルのエントリは、[Metadata 2.3](https://packaging.python.org/en/latest/specifications/core-metadata/)仕様に従いますが、uvが読み取るのは`name`、`version`、`requires-dist`、`requires-python`、および`provides-extra`のみです。`version`フィールドもオプションと見なされます。省略された場合、メタデータは指定されたパッケージのすべてのバージョンに使用されます。

## 下限

デフォルトでは、`uv add`は依存関係に下限を追加し、uvを使用してプロジェクトを管理する場合、uvは直接依存関係に下限がない場合に警告します。

下限は「ハッピーパス」では重要ではありませんが、依存関係の競合がある場合には重要です。たとえば、プロジェクトが2つのパッケージを必要とし、それらのパッケージが競合する依存関係を持っている場合、リゾルバは2つのパッケージの制約内のすべてのバージョンの組み合わせをチェックする必要があります。すべてが競合する場合、依存関係が満たされないため、エラーが報告されます。下限がない場合、リゾルバは（しばしば）パッケージの最古のバージョンまでバックトラックすることができます。これは遅いだけでなく、古いバージョンのパッケージはビルドに失敗することがよくあり、リゾルバは競合するパッケージに依存しない古いバージョンを選択することができますが、コードと互換性がないこともあります。

ライブラリを書く場合、下限は特に重要です。ライブラリが動作する各依存関係の最も低いバージョンを宣言し、その境界が正しいことを確認することが重要です。そうしないと、ユーザーはライブラリの依存関係の古い互換性のないバージョンを受け取り、ライブラリが予期しないエラーで失敗します。

## 再現可能な解決

uvは、特定の日付前に公開されたディストリビューションに解決を制限する`--exclude-newer`オプションをサポートしており、新しいパッケージリリースに関係なくインストールを再現できます。日付は[RFC 3339](https://www.rfc-editor.org/rfc/rfc3339.html)タイムスタンプ（例：`2006-12-02T02:07:43Z`）またはシステムの設定されたタイムゾーンの同じ形式のローカル日付（例：`2006-12-02`）として指定できます。

パッケージインデックスは、[`PEP 700`](https://peps.python.org/pep-0700/)で指定された`upload-time`フィールドをサポートしている必要があります。特定のディストリビューションにフィールドが存在しない場合、そのディストリビューションは利用できないものと見なされます。PyPIはすべてのパッケージに対して`upload-time`を提供します。

再現性を確保するために、解決不能な解決のメッセージには、`--exclude-newer`フラグによってディストリビューションが除外されたことは言及されません。新しいディストリビューションは存在しないものとして扱われます。

!!! note

    `--exclude-newer`オプションは、レジストリから読み取られたパッケージにのみ適用されます（例：Git依存関係など）。さらに、`uv pip`インターフェースを使用する場合、uvは`--reinstall`フラグが提供されない限り、以前にインストールされたパッケージをダウングレードしません。この場合、uvは新しい解決を行います。

## ソースディストリビューション

[PEP 625](https://peps.python.org/pep-0625/)は、パッケージがソースディストリビューションをgzip tarball（`.tar.gz`）アーカイブとして配布する必要があると規定しています。この仕様の前には、後方互換性のためにサポートする必要がある他のアーカイブ形式も許可されていました。uvは次の形式のアーカイブの読み取りと抽出をサポートしています：

- gzip tarball（`.tar.gz`、`.tgz`）
- bzip2 tarball（`.tar.bz2`、`.tbz`）
- xz tarball（`.tar.xz`、`.txz`）
- zstd tarball（`.tar.zst`）
- lzip tarball（`.tar.lz`）
- lzma tarball（`.tar.lzma`）
- zip（`.zip`）

## 詳細を学ぶ

リゾルバの内部についての詳細は、[リゾルバリファレンス](../reference/resolver-internals.md)ドキュメントを参照してください。
