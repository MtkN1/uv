# キャッシュ

## 依存関係のキャッシュ

uvは、以前の実行で既にアクセスされた依存関係を再ダウンロード（および再ビルド）しないようにするために、積極的なキャッシュを使用します。

uvのキャッシュの詳細は、依存関係の性質に基づいて異なります：

- **レジストリ依存関係**（PyPIからダウンロードされたものなど）については、uvはHTTPキャッシュヘッダーを尊重します。
- **直接URL依存関係**については、uvはHTTPキャッシュヘッダーを尊重し、URL自体に基づいてもキャッシュします。
- **Git依存関係**については、uvは完全に解決されたGitコミットハッシュに基づいてキャッシュします。そのため、`uv pip compile`は解決された依存関係セットを書き込む際に、Git依存関係を特定のコミットハッシュに固定します。
- **ローカル依存関係**については、uvはソースアーカイブ（つまり、ローカルの`.whl`または`.tar.gz`ファイル）の最終変更日時に基づいてキャッシュします。ディレクトリの場合、uvは`pyproject.toml`、`setup.py`、または`setup.cfg`ファイルの最終変更日時に基づいてキャッシュします。

キャッシュの問題が発生した場合、uvにはいくつかの回避策があります：

- すべての依存関係のキャッシュデータを再検証するには、任意のコマンドに`--refresh`を渡します（例：`uv sync --refresh`または`uv pip install --refresh ...`）。
- 特定の依存関係のキャッシュデータを再検証するには、任意のコマンドに`--refresh-dependency`を渡します（例：`uv sync --refresh-package flask`または`uv pip install --refresh-package flask ...`）。
- 既存のインストール済みバージョンを無視するには、任意のインストールコマンドに`--reinstall`を渡します（例：`uv sync --reinstall`または`uv pip install --reinstall ...`）。

## 動的メタデータ

デフォルトでは、uvはローカルディレクトリ依存関係（例：編集可能なもの）を再ビルドおよび再インストールするのは、ディレクトリルートの`pyproject.toml`、`setup.py`、または`setup.cfg`ファイルが変更された場合のみです。これはヒューリスティックであり、場合によっては望まれるよりも少ない再インストールを引き起こすことがあります。

特定のパッケージのキャッシュキーに他の情報を組み込むには、`tool.uv.cache-keys`の下にキャッシュキーエントリを追加できます。これには、ファイルパスやGitコミットハッシュが含まれます。

例えば、プロジェクトが[`setuptools-scm`](https://pypi.org/project/setuptools-scm/)を使用しており、コミットハッシュが変更されるたびに再ビルドする必要がある場合、プロジェクトの`pyproject.toml`に次のように追加できます：

```toml title="pyproject.toml"
[tool.uv]
cache-keys = [{ git = { commit = true } }]
```

動的メタデータがGitタグのセットから情報を取得する場合、キャッシュキーをタグに拡張できます：

```toml title="pyproject.toml"
[tool.uv]
cache-keys = [{ git = { commit = true, tag = true } }]
```

同様に、プロジェクトが依存関係をポピュレートするために`requirements.txt`を読み取る場合、プロジェクトの`pyproject.toml`に次のように追加できます：

```toml title="pyproject.toml"
[tool.uv]
cache-keys = [{ file = "requirements.txt" }]
```

グロブは[`glob`](https://docs.rs/glob/0.3.1/glob/struct.Pattern.html)クレートの構文に従ってサポートされています。例えば、プロジェクトディレクトリまたはそのサブディレクトリ内の`.toml`ファイルが変更されるたびにキャッシュを無効にするには、次のようにします：

```toml title="pyproject.toml"
[tool.uv]
cache-keys = [{ file = "**/*.toml" }]
```

!!! note

    グロブの使用は高価になる可能性があります。uvはファイルが変更されたかどうかを判断するためにファイルシステムをウォークする必要があるかもしれません。
    これにより、大規模または深くネストされたディレクトリのトラバーサルが必要になる場合があります。

回避策として、`tool.uv.cache-keys`でカバーされていない`dynamic`メタデータを使用するプロジェクトの場合、プロジェクトを`tool.uv.reinstall-package`リストに追加して、uvに常に再ビルドおよび再インストールさせることができます：

```toml title="pyproject.toml"
[tool.uv]
reinstall-package = ["my-package"]
```

これにより、パッケージの`pyproject.toml`、`setup.py`、または`setup.cfg`ファイルが変更されたかどうかに関係なく、`my-package`を毎回再ビルドおよび再インストールするようにuvが強制されます。

## キャッシュの安全性

同じ仮想環境に対して複数のuvコマンドを同時に実行しても安全です。uvのキャッシュはスレッドセーフで追加専用に設計されており、複数の同時実行のリーダーおよびライターに対して堅牢です。uvはインストール時にターゲット仮想環境にファイルベースのロックを適用し、プロセス間の同時変更を回避します。

uvコマンドが実行中にuvキャッシュを変更する（例：`uv cache clean`）ことは安全ではなく、キャッシュを直接変更する（例：ファイルやディレクトリを削除する）ことは決して安全ではありません。

## キャッシュのクリア

uvはキャッシュからエントリを削除するためのいくつかのメカニズムを提供します：

- `uv cache clean`はキャッシュディレクトリからすべてのキャッシュエントリを削除し、完全にクリアします。
- `uv cache clean ruff`は`ruff`パッケージのすべてのキャッシュエントリを削除し、単一または有限のパッケージのキャッシュを無効にするのに便利です。
- `uv cache prune`はすべての未使用のキャッシュエントリを削除します。例えば、キャッシュディレクトリには、もはや必要ない以前のuvバージョンで作成されたエントリが含まれている場合があります。`uv cache prune`は定期的に実行してキャッシュディレクトリをクリーンに保つのが安全です。

## 継続的インテグレーションでのキャッシュ

継続的インテグレーション環境（GitHub ActionsやGitLab CIなど）では、パッケージインストールアーティファクトをキャッシュして、後続の実行を高速化することが一般的です。

デフォルトでは、uvはソースからビルドされたホイールと直接ダウンロードされた事前ビルドホイールの両方をキャッシュし、高性能なパッケージインストールを可能にします。

ただし、継続的インテグレーション環境では、事前ビルドホイールを永続化することは望ましくない場合があります。uvを使用すると、キャッシュから事前ビルドホイールを省略し（代わりに各実行時にレジストリから再ダウンロードします）、ソースからビルドされたホイールをキャッシュする方が高速になることがよくあります。特に拡張モジュールの場合、ホイールビルドプロセスが高価であるため、ソースからビルドされたホイールをキャッシュすることは価値があります。

このキャッシュ戦略をサポートするために、uvは`uv cache prune --ci`コマンドを提供し、すべての事前ビルドホイールと解凍されたソースディストリビューションをキャッシュから削除し、ソースからビルドされたホイールを保持します。最大のキャッシュ効率を確保するために、継続的インテグレーションジョブの最後に`uv cache prune --ci`を実行することをお勧めします。例については、[GitHubインテグレーションガイド](../guides/integration/github.md#caching)を参照してください。

## キャッシュディレクトリ

uvは、次の順序でキャッシュディレクトリを決定します：

1. `--no-cache`が要求された場合、一時的なキャッシュディレクトリ。
2. `--cache-dir`、`UV_CACHE_DIR`、または[`tool.uv.cache-dir`](../reference/settings.md#cache-dir)で指定された特定のキャッシュディレクトリ。
3. システムに適したキャッシュディレクトリ。例：Unixでは`$XDG_CACHE_HOME/uv`または`$HOME/.cache/uv`、Windowsでは`%LOCALAPPDATA%\uv\cache`

!!! note

    uvは常にキャッシュディレクトリを必要とします。`--no-cache`が要求された場合でも、uvはその単一の呼び出し内でデータを共有するために一時的なキャッシュを使用します。

    ほとんどの場合、`--no-cache`の代わりに`--refresh`を使用するべきです。これにより、キャッシュが更新され、後続の操作でキャッシュが読み取られなくなります。

キャッシュディレクトリがuvが操作するPython環境と同じファイルシステム上にあることがパフォーマンスにとって重要です。そうでない場合、uvはキャッシュから環境にファイルをリンクできず、代わりに遅いコピー操作にフォールバックする必要があります。

## キャッシュのバージョン管理

uvのキャッシュは、いくつかのバケット（例：ホイール用のバケット、ソースディストリビューション用のバケット、Gitリポジトリ用のバケットなど）で構成されています。各バケットはバージョン管理されており、リリースにキャッシュ形式への破壊的な変更が含まれている場合、uvは互換性のないキャッシュバケットを読み書きしようとしません。

例えば、uv 0.4.13にはコアメタデータバケットへの破壊的な変更が含まれていました。そのため、バケットバージョンはv12からv13に増加しました。

キャッシュバージョン内では、変更は前方互換性が保証されていますが、後方互換性は保証されていません。

例えば、uv 0.4.8はuv 0.4.7によって書き込まれたキャッシュエントリを読み取ることができますが、uv 0.4.7はuv 0.4.8によって書き込まれたキャッシュエントリを読み取ることができません。その結果、uvの複数のバージョン間でキャッシュディレクトリを共有することは安全です。これらのバージョンが時間とともに厳密に増加する限り、これは本番および開発環境で一般的です。

複数のuvバージョンを継続的に使用する場合、各バージョンに対して別々のキャッシュを使用することをお勧めします。例えば、uv 0.4.8によってポピュレートされたキャッシュは、uv 0.4.7によって使用できない場合があります。リリース間でキャッシュバージョンが変更されていない場合でも同様です。
